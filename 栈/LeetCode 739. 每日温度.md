# LeetCode 739. 每日温度

## 1. 题目描述

根据每日 `气温` 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 `0` 来代替。

```
1. temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
返回: [1, 1, 4, 2, 1, 1, 0, 0]

2. temperatures = [1, 2, 3, 4, 5]
返回: [1, 1, 1, 1, 0]

3. temperatures = [5, 4, 3, 2, 1]
返回: [0, 0, 0, 0, 0]

4. temperatures = [20, 20, 20, 21, 22]
返回: [3, 2, 1, 1, 0]
```

## 2. 题解

思路: 

​	看到这个题首先想到的是动态规划, 但是做了一下, 效果并不理想, 然后去看了下官方题解, 采用单调栈的方式

单调栈: 构建一个列表模拟栈, 内部存放当前元素的下标, 如果下一个元素的值大于这个元素, 就出栈,不论这个元素出没出栈, 下一个元素都要入栈, 然后继续遍历, 所以栈内保证从上到下依次递增, 也就是栈底是最大的元素, 每次判断一个元素都要循环判断, 因为不确定栈内有几个元素.

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
    	# 获取列表长度
        size = len(T)
        # 构建返回列表
        l = [0]*size
        # 构建模拟栈列表
        stack = []
        
        # 遍历列表, 获取下标和值
        for i, v in enumrate(T):
            # 循环判断是否出栈
            while stack and T[stack[-1]] < v:
                # 对应位置赋值, 元素出栈
                l[stack.pop(-1)] = i - stack[-1]
            	# 注意: 赋值运算自右向左运行, 先执行stack[-1], 后执行stack.pop(-1)
            # 当前元素下标入栈
            stack.append(i)
        return l
```

