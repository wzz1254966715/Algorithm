# LeetCode 873.最长斐波那契子序列长度

## 1. 题目描述

如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：

n >= 3
对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）

大白话: 最少三个数的序列,第三项开始,当前项等于前两项之和

```
输入: [1,2,3,4,5,6,7,8]
输出: 5
解释:
最长的斐波那契式子序列为：[1,2,3,5,8] 。

输入: [1,3,7,11,12,14,18]
输出: 3
解释:
最长的斐波那契式子序列有：
[1,11,12]，[3,11,14] 以及 [7,11,18] 。
```

```
3 <= A.length <= 1000
1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9
```

## 2. 题目解析

动态规划类

遍历每一个数,判断当前数和前几项的差是否在列表中,并统计子序列长度

构建dp字典,第三项和第二项作为key,序列长度作为值

key: (1, 2) -> (2, 3) -> (3, 5) -> (5, 8)....

value: 0           3           4           5

从第三项开始计算,初始值就为3,以后每次加1

```python
class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
        dp = {}
        # 长度
        res = 0
        # 为什么使用集合在下面使用时解释
        set_A = set(A)
        for i in range(1, len(A)):
            # 只遍历前面的数就可以
            for j in range(i):
                n = A[i] - A[j]
                # 判断差值是否在当前数的前面
                # in操作在集合和列表上的表现天差地别,在集合上异常的快
                if n < A[j] and n in set_A:
                    #(1, 2)->(2, 3)->(3, 5)->(5, 8)...
                    #   0       3       4       5
                    # 由于每种序列的前两个元素都没有计算,所以缺省为2
                    # 只要计算在内的序列,最少是3
                    dp[(A[j], A[i])] = dp.get((n, A[j]), 2) + 1
                    # 统计最长
                    res = max(res, dp[(A[j], A[i])])
        return res
```

