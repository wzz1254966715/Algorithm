# LeetCode 1277. 统计全为1的正方形子矩阵

## 1. 题目描述

给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。

```
输入：matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
输出：15
解释： 
边长为 1 的正方形有 10 个。
边长为 2 的正方形有 4 个。
边长为 3 的正方形有 1 个。
正方形的总数 = 10 + 4 + 1 = 15.

1 <= arr.length <= 300
1 <= arr[0].length <= 300
0 <= arr[i][j] <= 1
```

## 2. 题解

### 动态规划题:

从左上角开始遍历二维列表

1*1: 如果为1,那么就设置为1

2*2: 看四个点,如果都是1,那么就能构成一个2*2的正方形,那么这个点的位置就有两个正方形(一个是本身)

3*3: 看最右下角的四个点,首先却表右下角是1,其它三个点都为2的时候就代表右下角周围有三个2阶的正方形,

那么这个点的值就为3,代表一个1阶一个2阶一个3阶正方形



```python
class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
    	# 获取行列长度
        len_i = len(matrix)
        len_j = len(matrix[0])
        # 生成全0列表,大小与matrix一致
        dp = [[0]*len_j for i in range(len_i)]
        # 初始化正方形个数为0
        count = 0
        # 遍历数组
        for i in range(len_i):
            for j in range(len_j):
            	# 当前元素如果为0直接结束本次循环
                if matrix[i][j] == 0:
                    continue
                # 上边界和左边界的值,直接设置为1就可以,上一步已经将为0的剔除掉了
                elif i == 0 or j == 0:
                	 # 也可以写为 dp[i][j] = matrix[i][j]
                    dp[i][j] = 1
                else:
                	# 根据三个方向的值确定右下角的点在介个正方形中
                	# +1 是因为本身这个点也是一个一阶正方形
                    dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1
               	# 得到的dp值就代表这个点在几个正方形中,就是正方形的个数
                count += dp[i][j]

        return count
```

